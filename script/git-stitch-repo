#!/usr/bin/env perl
use strict;
use warnings;
use File::Basename;
use lib dirname($0) . '/lib';
use Git::FastExport;
use List::Util qw( min max );

my %repo;

die "Odd number of parameters\nUsage: merge-repos [ repo dir ] ...\n"
    if @ARGV % 2;

# process command-line parameters
while (@ARGV) {
    my ( $repo, $dir ) = splice( @ARGV, 0, 2 );
    $repo{$repo}{dir}  = $dir;
    $repo{$repo}{repo} = $repo;
}

# create an export parser for each repo
for my $repo ( keys %repo ) {
    my $parser = Git::FastExport->new();
    $parser->fast_export( $repo{$repo}{repo},
        '--progress=1 --all --date-order' );
    $parser->{mapdir} = $repo{$repo}{dir};
    $repo{$repo}{parser} = $parser;
}

# repositories that we will process
my @repos = values %repo;

my $mark = 1_000_000;    # mark counter in the new rpo
my %mark_map;            # map marks in source repos to marks in the new repo

# get the first commits
$_->{commit} = next_commit( $_->{parser} ) for @repos;

# main loop
use Data::Dumper;
my $last;
my %commits;
while (@repos) {

    # sort by date
    @repos = sort { $a->{commit}{date} <=> $b->{commit}{date} } @repos;
    my $repo = $repos[0];

    # next commit to dump
    my $commit = $repo->{commit};

    # update marks & dir in files
    for ( @{ $commit->{files} } ) {
        s/^M (\d+) :(\d+)/M $1 :$mark_map{$repo->{repo}}{$2}/;
        if ( my $dir = $repo->{dir} ) {
            s!^(M \d+ :\d+) (.*)!$1 $dir/$2!;    # filemodify
            s!^D (.*)!D $dir/$1!;                # filedelete

            # /!\ quotes may happen - die and fix if needed
            die "Choked on quoted paths in $repo->{repo}! Culprit:\n$_\n"
                if /^[CR] \S+ \S+ /;

            # filecopy | filerename
            s!^([CR]) (\S+) (\S+)!$1 $dir/$2 $dir/$3!;
        }
    }

    # first commit in the old repo linked to latest commit in new repo
    if ( $last && !$commit->{from} ) {
        $commit->{from} = ["from :$last"];
    }

    # update historical information
    my ($id) = $commit->{mark}[0] =~ /:(\d+)/g;
    $last = $id;    # last commit applied
    my $branch = ( split / /, $commit->{header} )[1];
    my $node = $commits{$id} = {
        name     => $id,
        repo     => $repo->{repo},
        branch   => $branch,
        children => [],
        merge    => exists $commit->{merge},
    };

    # this commit's parents
    my @parents = map {/:(\d+)/g} @{ $commit->{from} || [] },
        @{ $commit->{merge} || [] };

    # map each parent to its last "alien" commit
    my %parent_map = map {
        $_ => last_alien_child( $commits{$_}, $repo->{repo}, $branch )->{name}
    } @parents;

    # map parent marks
    for ( @{ $commit->{from} || [] }, @{ $commit->{merge} || [] } ) {
        if (m/^(from|merge) /) {
            s/:(\d+)/:$parent_map{$1}/g;
        }
    }

    # update the parents information
    for my $parent ( map { $parent_map{$_} } @parents ) {
        push @{ $commits{$parent}{children} }, $node;
    }

    # dump the commit
    print $commit->as_string;

    # load next commit
    $repo->{commit} = next_commit( $repo->{parser} )
        or shift @repos;    # no more blocks in this export
}

# return the next commit
# - print out the intermediate blocks
# - offset the old marks
sub next_commit {
    my ($parser) = @_;
    my $block;

    while ( $block = $parser->next_block() ) {

        # map to the new mark
        for ( @{ $block->{mark} || [] } ) {
            s/:(\d+)/:$mark/
                and $mark_map{ $parser->{source} }{$1} = $mark++;
        }

        # update marks in from & merge
        for ( @{ $block->{from} || [] }, @{ $block->{merge} || [] } ) {
            if (m/^(from|merge) /) {
                s/:(\d+)/:$mark_map{$parser->{source}}{$1}/g;
            }
        }
        last if $block->{type} eq 'commit';
        print $block->as_string();
    }
    return $block;
}

# find the last child of this node
# that has either no child
# or a child in our repo
sub last_alien_child {
    my ( $node, $repo, $branch ) = @_;

    while (1) {

        # no children nodes
        return $node if ( !@{ $node->{children} } );

        # some children nodes are local
        return $node if grep { $_->{repo} eq $repo } @{ $node->{children} };

        # there's a child in the same branch
        if ( my ($peer)
            = grep { $_->{branch} eq $branch } @{ $node->{children} } )
        {
            # but don't go past another repo's merges
            return $node if $peer->{merge};
            $node = $peer;
        }

        # or pick the first child (as good as any)
        else {

            $node = $node->{children}[0];
        }
    }
}
